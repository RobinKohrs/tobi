library(tidyverse)
here
here()
# load api key ------------------------------------------------------------
readLines(here(".env"))
library(here)
library(tidyverse)
library(here)
library(glue)
library(sf)
library(rajudas)
library(jsonlite)
# load api key ------------------------------------------------------------
readLines(here(".env"))
# load api key ------------------------------------------------------------
apiKey = readLines(here(".env"))
library(glue)
"asdasd"
a = "hi"
glue("{a} Mom")
# constant variables ------------------------------------------------------
path_zaehlbezirk = here("data_raw/Data/Census Districts/ZAEHLBEZIRKOGDPolygon.shp")
# urls ------------------------------------------------------
base_here_url = glue("https://isoline.route.ls.hereapi.com/routing/7.2/calculateisoline.json?apiKey={apiKey}")
base_here_url
# load data ---------------------------------------------------------------
zbez = read_sf(path_zaehlbezirk)
mapview::mapview(zbez)
# centroids ---------------------------------------------------------------
cents = st_centroid(zbez)
cents
library(mapview)
mapview(zbez) + mapview(cents)
# calculate isochrones ----------------------------------------------------
isochrones = c(5,10,15)
isochrones
for (i in isochrones) {
print(i)
}
for (i in seq_along(isochrones)) {
print(i)
}
seq_along(isochrones)
cents
nrow(cents)
for(j in 1:nrow(cents)) {
print(j)
}
cents
cents[1,2]
cents[1,2] %>% st_drop_geometry()
cents[1,2,drop=T]
val = cents[1,2,drop=T]
val
as.numeric(val)
j
j = 1
# j is the row index
row = cents[j, ]
row
plot(row[0])
# get the coordinates
st_coordinates(row)
# get the coordinates
coords = st_coordinates(row)
x = coords[1,1]
y = coords[1,2]
x
y
x
y
install.packages("hereR")
library(hereR)
?hereR::isoline()
row
Sys.time()
# i is the index
# val is the gehminutes
iso_time_minutes = isochrones[i]
iso_time_seconds = iso_time_minutes * 60
# send request to api -----------------------------------------------------
# build url
res = hereR::isoline(row, datetime = Sys.time(), range = iso_time_seconds, range_type = "time")
# set api key
hereR::set_key(api_key)
# set api key
hereR::set_key(apiKey)
# set api key
hereR::set_key(apiKey)
# send request to api -----------------------------------------------------
# build url
res = hereR::isoline(row, datetime = Sys.time(), range = iso_time_seconds, range_type = "time")
res
mapview(res)
# send request to api -----------------------------------------------------
# build url
res = hereR::isoline(row, datetime = Sys.time(), range = iso_time_seconds, range_type = "time", transport_mode = "pedestrian")
mapview(res)
mapview(res) + mapview(row)
# send request to api -----------------------------------------------------
# build url
res = hereR::isoline(row, datetime = Sys.time(), range = c(iso_time_seconds/2, iso_time_seconds, iso_time_seconds * 2), range_type = "time", transport_mode = "pedestrian")
res
plot(res)
mapview(res)
row
res
library(purrr)
arr = c(1,2,3)
arr
for(i in arr){
print(i)
}
# map
map(arr, function(i){
print(i)
})
# map
res = map(arr, function(i){
print(i)
return(i * 2)
})
res
for(i in arr){
print(i)
}
# map
res = map(arr, function(i){
print(i)
return(i * 2)
})
res
j = 1
j =
j = 1
# j is the row index
row = cents[j, ]
row
# time in seconds
isochrones *60
# time in seconds
times = isochrones *60
# use hereR package
res = hereR::isoline(
row,
datetime = Sys.time(),
range = times,
range_type = "time",
transport_mode = "pedestrian"
)
res
res[["zbez"]] = row$ZBEZNR
res
1:nrow(cents)[1:20]
1:nrow(cents)
1:nrow(cents)[1:20]
1:nrow(cents)
1:nrow(cents)[20]
1:nrow(cents) %>% head(n=20)
cat(glue("{j} / 20"), "\r")
results = map(1:nrow(cents) %>% head(n=20), function(j){
cat(glue("{j} / 20"), "\r")
# j is the row index
row = cents[j, ]
# send request to api -----------------------------------------------------
# time in seconds
times = isochrones *60
# use hereR package
res = hereR::isoline(
row,
datetime = Sys.time(),
range = times,
range_type = "time",
transport_mode = "pedestrian"
)
res[["zbez"]] = row$ZBEZNR
return(res)
})
results
results = map(1:nrow(cents) %>% head(n=20), function(j){
cat(glue("{j} / 20"), "\r")
# j is the row index
row = cents[j, ]
# send request to api -----------------------------------------------------
# time in seconds
times = isochrones *60
# use hereR package
res = hereR::isoline(
row,
datetime = Sys.time(),
range = times,
range_type = "time",
transport_mode = "pedestrian"
)
res[["zbez"]] = row$ZBEZNR
Sys.sleep(0.2)
return(res)
})
results = map(1:nrow(cents) %>% head(n=20), function(j){
cat(glue("{j} / 20"), "\r")
# j is the row index
row = cents[j, ]
# send request to api -----------------------------------------------------
# time in seconds
times = isochrones *60
# use hereR package
res = hereR::isoline(
row,
datetime = Sys.time(),
range = times,
range_type = "time",
transport_mode = "pedestrian"
)
res[["zbez"]] = row$ZBEZNR
Sys.sleep(1)
return(res)
})
results
# bind all rows together --------------------------------------------------
all_isochrones = bind_rows(results)
all_isochrones
mapview(all_isochrones, zcol="zbez")
# calculate isochrones ----------------------------------------------------
isochrones = c(15)
# calculate isochrones ----------------------------------------------------
isochrones = c(15)
# set api key
hereR::set_key(apiKey)
results = map(1:nrow(cents) %>% head(n=20), function(j){
cat(glue("{j} / 20"), "\r")
# j is the row index
row = cents[j, ]
# send request to api -----------------------------------------------------
# time in seconds
times = isochrones *60
# use hereR package
res = hereR::isoline(
row,
datetime = Sys.time(),
range = times,
range_type = "time",
transport_mode = "pedestrian"
)
res[["zbez"]] = row$ZBEZNR
Sys.sleep(1)
## save to disk
# write_sf(res, path)
return(res)
})
# fake points (centroids) -------------------------------------------------------------
cents
rowIndex = 1
row = all_isochrones[rowIndex, ]
row
mapview(row)
# make it bigger -> dont do that
fake_polygon = st_buffer(row, 0.01)
mapview(fake_polygon)
# make it bigger -> dont do that
fake_polygon = st_buffer(row, 0.1)
mapview(fake_polygon)
row
# make it bigger -> dont do that
fake_polygon = st_buffer(row, 1)
mapview(fake_polygon)
# make it bigger -> dont do that
fake_polygon = st_buffer(row, 1000)
mapview(fake_polygon)
# make it bigger -> dont do that
fake_polygon = st_buffer(row, 5000)
mapview(fake_polygon)
# make it bigger -> dont do that
fake_polygon = st_buffer(row, 3000)
# find all the points (service provider in real life)
st_intersects(fake_polygon, cents)
# find all the points (service provider in real life)
cents[fake_polygon, ]
cents[1,2]
cents[fake_polygon, "geometry"]
mapview(fake_polygon) + mapview(intersecting_points)
# find all the points (service provider in real life)
intersecting_points = cents[fake_polygon, ]
mapview(fake_polygon) + mapview(intersecting_points)
intersecting_points
# for each isochrone find all the points within
intersecting_points_for_each_isochrone = map(1:nrow(all_isochrones), function(rowIndex){
row = all_isochrones[rowIndex, ]
# make it bigger -> dont do that
fake_polygon = st_buffer(row, 3000)
# find all the points (service provider in real life)
intersecting_points = cents[fake_polygon, ]
return(intersecting_points)
})
intersecting_points_for_each_isochrone %>% length()
results
# bind all rows together --------------------------------------------------
all_isochrones = bind_rows(results)
all_isochrones
# for each isochrone find all the points within
intersecting_points_for_each_isochrone = map(1:nrow(all_isochrones), function(rowIndex){
row = all_isochrones[rowIndex, ]
# make it bigger -> dont do that
fake_polygon = st_buffer(row, 3000)
# find all the points (service provider in real life)
intersecting_points = cents[fake_polygon, ]
return(intersecting_points)
})
intersecting_points_for_each_isochrone
intersecting_points_for_each_isochrone[[1]]
# for each isochrone find all the points within
intersecting_points_for_each_isochrone = map(1:nrow(all_isochrones), function(rowIndex){
row = all_isochrones[rowIndex, ]
# make it bigger -> dont do that
fake_polygon = st_buffer(row, 3000)
# find all the points (service provider in real life)
intersecting_points = cents[fake_polygon, ]
intersecting_points[["isochrone_id"]] = rowIndex
return(intersecting_points)
})
# plot --------------------------------------------------------------------
df_all_points = bind_rows(intersecting_points_for_each_isochrone)
df_all_points
df_all_points %>% glimpse
intersecting_points_for_each_isochrone[[1]]
rowIndex = 1
row = all_isochrones[rowIndex, ]
# make it bigger -> dont do that
fake_polygon = st_buffer(row, 3000)
# find all the points (service provider in real life)
intersecting_points = cents[fake_polygon, ]
intersecting_points[["isochrone_id"]] = rowIndex
intersecting_points
# for each isochrone find all the points within
intersecting_points_for_each_isochrone = map(1:nrow(all_isochrones), function(rowIndex){
row = all_isochrones[rowIndex, ]
# make it bigger -> dont do that
fake_polygon = st_buffer(row, 3000)
# find all the points (service provider in real life)
intersecting_points = cents[fake_polygon, ]
intersecting_points[["isochrone_id"]] = rowIndex
return(intersecting_points)
})
# plot --------------------------------------------------------------------
df_all_points = bind_rows(intersecting_points_for_each_isochrone)
df_all_points
mapview(df_all_points, zcol="isochrone_id")
mapview(df_all_points, zcol="isochrone_id") + mapview(all_isochrones)
# symetrical difference in R ----------------------------------------------
a = read_sf("~/Desktop/deelte/one.geojson")
b = read_sf("~/Desktop/deelte/two.geojson")
plot(a)
plot(b, add=T)
symDif = st_sym_difference(a,b)
mapview(a) + mapview(b)
mapview(a) + mapview(b) + mapview(symDif)
sf::sf_use_s2(false)
sf::sf_use_s2(use_s2 = F)
symDif = st_sym_difference(a,b)
mapview(a) + mapview(b) + mapview(symDif)
# calculate isochrones ----------------------------------------------------
isochrones = c(15)
# set api key
hereR::set_key(apiKey)
results = map(1:nrow(cents), function(j){
cat(glue("{j} / 20"), "\r")
# j is the row index
row = cents[j, ]
# send request to api -----------------------------------------------------
# time in seconds
times = isochrones *60
# use hereR package
res = hereR::isoline(
row,
datetime = Sys.time(),
range = times,
range_type = "time",
transport_mode = "pedestrian"
)
res[["zbez"]] = row$ZBEZNR
# sleep to not get banned from API
Sys.sleep(1)
## save to disk
# write_sf(res, path)
return(res)
})
centrs
cents
results = map(1:nrow(cents), function(j){
cat(glue("{j} / 250"), "\r")
# j is the row index
row = cents[j, ]
# send request to api -----------------------------------------------------
# time in seconds
times = isochrones *60
# use hereR package
res = hereR::isoline(
row,
datetime = Sys.time(),
range = times,
range_type = "time",
transport_mode = "pedestrian"
)
res[["zbez"]] = row$ZBEZNR
# sleep to not get banned from API
Sys.sleep(1)
## save to disk
# write_sf(res, path)
return(res)
})
results = map(1:nrow(cents), function(j){
cat(glue("{j} / 250"), "\r")
# j is the row index
row = cents[j, ]
# send request to api -----------------------------------------------------
# time in seconds
times = isochrones *60
# use hereR package
res = hereR::isoline(
row,
datetime = Sys.time(),
range = times,
range_type = "time",
transport_mode = "pedestrian"
)
res[["zbez"]] = row$ZBEZNR
# sleep to not get banned from API
Sys.sleep(1)
## save to disk
# write_sf(res, path)
return(res)
})
results = map(1:nrow(cents), function(j){
cat(glue("{j} / 250"), "\r")
# j is the row index
row = cents[j, ]
# send request to api -----------------------------------------------------
# time in seconds
times = isochrones *60
# use hereR package
res = hereR::isoline(
row,
datetime = Sys.time(),
range = times,
range_type = "time",
transport_mode = "pedestrian"
)
res[["zbez"]] = row$ZBEZNR
# sleep to not get banned from API
Sys.sleep(1)
## save to disk
# write_sf(res, path)
return(res)
})
